{"name":"Suid","tagline":"Distributed Service-Unique IDs that are short and sweet.","body":"# suid\r\nDistributed Service-Unique IDs that are short and sweet.\r\n\r\nSuids are IDs that are:\r\n\r\n* Unique across a service or site\r\n* Short\r\n* Ordered\r\n* Human readable, write-able and pronouncable\r\n* 53 bits so they fit into a single Javascript or PHP Number, Java Long, Int64 etc.\r\n\r\n## Download\r\n* [Commented (~7kB)](https://github.com/Download/suid/releases/download/0.9.0/suid.js)\r\n* [Minified (~3 KB)](https://github.com/Download/suid/releases/download/0.9.0/suid.min.js)\r\n\r\n## Usage\r\n* Install suid.js on your server\r\n* Include it on your webpage\r\n* Configure the URL to the suid server using the `data-suid-server` attribute\r\n* Pass options to it using the `data-suid-options` attribute\r\n* Call `Suid()` to generate IDs\r\n\r\n## Example\r\n\r\n\t<script src=\"lib/suid/suid.js\" \r\n\t\t\tdata-suid-server=\"suid/suid.json\"\r\n\t\t\tdata-suid-options=\"{'min':3, 'max':3}\"></script>\r\n\r\nLater on:\r\n\r\n\tvar myId = Suid();\r\n\talert(myId);             // 14shd\r\n\talert(myId.valueOf());   // 1204748\r\n\tvar halve = myId / 2;\r\n\tvar halveId = new Suid(halve);\r\n\talert(halve);            // 602374\r\n\talert(halveId);          // jd86\r\n\t\r\n*Don't create new IDs by adding to existing IDs! Just call `Suid()` again.*\r\n\r\n## Need a server? \r\nCheck out the Java EE implementation: [suid-server-java](http://download.github.io/suid-server-java/)\r\n\r\n## Options\r\nThe suid script fetches suid blocks from the suid server and stores them in a pool in [localStorage](http://www.w3.org/TR/webstorage/#storage) ([browser support](http://caniuse.com/#search=localstorage)). This pool is accessible from all tabs that are from the same domain, maximizing the efficient use of suid blocks. \r\n\r\nYou can control the behaviour of the pool with two settings:\r\n  \r\n* `min`: Minimum number of suid blocks to keep in the pool, defaults to 2\r\n* `max`: Maximum number of suid blocks to keep in the pool, defaults to 2\r\n\r\nOption `min` determines how low the amount of blocks in the pool may become before the script will request new blocks from the server. Option `max` determines how many blocks the script will fetch during each request in order to fill the\r\npool up again. If your application has moments in which it consumes a lot of IDs in a short timeframe, or if your application is expected to be used offline for prolonged periods, choose a `min` that ensures enough IDs will always\r\nbe in the pool to supply those IDs. If you want to reduce the number of requests for ID blocks (at the expense of more ID blocks going wasted when caches are cleared etc) choose a `max` that is a number of blocks higher then your `min`.\r\n\r\nAt most 8 blocks can be requested from the pool simultaneously so bear this in mind when configuring your pool. I would guess that the default settings are good enough for most people.\r\n\r\n## Why Suids?\r\nDatabase IDs are ususally generated by the database itself, using auto-increment. \r\nThe big downside of this is that we need to interact with the server whenever we\r\nneed an ID. When we create new objects, we have to leave the ID field blank for\r\nthe server to fill in later. When we want to refer to those new objects, we can't\r\nuntil we have created the new object on the server and have been issued an ID.\r\nThis creates a strong dependency on the server that is detrimental for offline apps.\r\nFurthermore database ID's are only unique for the table they correspond with.\r\nHaving *just* an ID, we cannot know which record it corresponds with. We would like\r\nto have IDs which are unique across all our tables. \r\n\r\nTo solve these issues we can use a distributed ID generator. We could use GUIDs\r\nbut they are loooooong. There are some nice solutions out there using randomness \r\nto generate short IDs, such as [shortid](https://github.com/dylang/shortid). \r\nHowever, random-based ID's have a balancing act between uniqueness and length. \r\nMake them too short and you *will* get collisions. Make them too long and they \r\nare... well... too long!  ;)\r\n\r\nAlso these ID generators don't generate ordered IDs. This can be an advantage (from \r\na security perspective) but you also lose a lot of pleasant properties that come\r\nwith ordered IDs. One of which is that with ordered IDs you start with the shortest\r\npossible IDs and end with the long ones. \r\n\r\nSo.. is there middle ground? The best of both worlds? I think so. Which is why I\r\nbuilt Suid.\r\n\r\nSuids are coordinated by a central server. The server hands out ID blocks, each of\r\nwhich allows an ID generator to generate up to 256 IDs without any further need\r\nfor communication with the server. It's implementation is inspired by \r\n[the mechanism Flickr uses](http://code.flickr.net/2010/02/08/ticket-servers-distributed-unique-primary-keys-on-the-cheap/)\r\nfor generating their IDs. Flickr however serves IDs one at a time, whereas Suid\r\nservers hand out IDs in blocks of 256 to minimize network overhead and facilitate\r\nlonger periods of offline usage.\r\n\r\nSuids fit in 53-bits, which means they can be treated as a native number in all\r\nmajor programming languages, including PHP and Javascript. And because they are\r\nordered, they start out *very* short and only grow longer as time goes by and\r\nmore and more of them are issued. They will never become longer than 11 characters.\r\nHere is an example of the length of the ID as more and more IDs get issued:\r\n\r\n\tBefore 1K: XX\r\n\tAfter 1K:  XXX\r\n\tAfter 1M:  XXXXX\r\n\tAfter 1G:  XXXXXXX\r\n\tAfter 1T:  XXXXXXXXX\r\n\tAfter 1P:  XXXXXXXXXXX\r\n\r\nThe first thousand IDs can be encoded using just two characters. Between a thousand \r\nand a million IDs can be generated that use three to four characters. From a million\r\nto a billion IDs can be generated using five to six characters. Only after we have\r\nissued dozens of billions of IDs do we get IDs of 8 characters or longer.\r\n \r\nThe total ID space of a suid can contain `9,007,199,254,740,992` or \r\n9 quadrillion, 7 trillion, 199 billion, 254 million, 740 thousand 992 IDs.  :)\r\n\r\n\r\n## Technical background\r\nThe 53 bits in a suid are distributed over a 64-bit long as depicted below:\r\n\r\n\t                 HIGH INT                                         LOW INT\r\n\t________________________________________________________________________________________________\r\n\t|                                               |                                               |\r\n\t| 0000 0000 | 000b bbbb | bbbb bbbb | bbbb bbbb | bbbb bbbb | bbbb bbbb | bbbb bbii | iiii iiss |\r\n\t|_______________________________________________|_______________________________________________|\r\n \r\n\t0 = 11 reserved bits\r\n\tb = 43 block bits\r\n\ti = 8 ID bits\r\n\ts = 2 shard bits\r\n\r\nThe first 11 bits are reserved and always set to `0`. The next 43 bits are used for\r\nthe `block` number. These are handed out by a centralized server. Then there are 8 `ID`\r\nbits which are to be filled in by the generator. The last 2 bits are reserved for the `shard`\r\nID. To prevent a single point of failure, up to 4 individual hosts can be handing out \r\nID's for a certain domain, each with their own `shard` ID.\r\n\r\nTo make the String representation of suids both short and easy for humans to read, write \r\nand pronounce, an encoding scheme is used based on the alphanumerals [a-z,0-9] as follows: \r\n\r\n\t0123456789a c defghijk mn p rstuvwxyz  = 32 character alphabet\r\n\t             ^         ^  ^ ^ \r\n\t             b         l  o q\r\n\t\r\n\tbloq = 4 Replacement symbols:\r\n\t\tb = 00\r\n\t\tl = 01\r\n\t\to = 02\r\n\t\tq = 03\r\n\r\nUsing only lowercase the alphanumerals give us 36 individual tokens in our alphabet. \r\nTo make things simpler, we take out 4 characters and use them as replacement symbols \r\ninstead: `'b'`, `'l'`, `'o'` and `'q'`.\r\nNow we end up with a 32 token alphabet, neatly encoding 5 bits per token.\r\n\r\nWe can use the replacement symbols to perform some 'compression'. Using the fact \r\nthat all blocks will end with the characters `'00'`, `'01'`, `'02'` or `'03'` \r\n(for shards 0 .. 3) we can save one character off any block suid by replacing the \r\ncharacter sequence by it's corresponding replacement symbol. This at the same time \r\nuniquely marks a suid as a block suid.\r\n\r\n## Copyright\r\nCopyright (c) 2015 by Stijn de Witt. Some rights reserved.\r\n\r\n## License\r\nCreative Commons Attribution 4.0 International (CC BY 4.0)\r\nhttps://creativecommons.org/licenses/by/4.0/\r\n\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}